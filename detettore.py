#!/usr/bin/env python

""" dettetore - a program to detect and characterize transposable element polymorphisms

Copyright (C) 2018 C. Stritt
License: GNU General Public License v3. See LICENSE.txt for details.
"""

import argparse
import logging
import os

from scripts import strumenti


def get_args():

    parser = argparse.ArgumentParser(
        description='Detect TE polymorphisms from paired-end read data')

    # Parameter groups
    parser_input = parser.add_argument_group('INPUT FILES')
    parser_settings = parser.add_argument_group('PROGRAM SETTINGS')
    parser_thresholds = parser.add_argument_group('ALIGNMENT AND MAPPING THRESHOLDS')


    # FILES
    parser_input.add_argument('-b', dest="bamfile",
                        required=True,
                        help='bwa mem alignment to reference genome.')

    parser_input.add_argument('-t', dest="targets",
                        required=True,
                        help='Target sequences in fasta format.')

    parser_input.add_argument("-r", dest="reference",
                        required=True,
                        help='Reference genome in fasta format. Required to calculate read statistics')

    parser_input.add_argument('-a', dest="annot",
                        help='TE annotation in gff or bed format. Required for absence module.')


    # PROGRAM SETTINGS
    parser_settings.add_argument('-m', dest='modus',
                        nargs='+', required=True,
                        choices=['tips','taps'],
                        help='Program modus.')

    parser_settings.add_argument('-o', dest='outfolder',
                        default='resultati', required=True,
                        help='Name of output folder.')

    parser_settings.add_argument('-p', dest='ploidy',
                        type=int, default=2,
                        help='Ploidy used to calculate genotype likelihoods. [2]')

    parser_settings.add_argument('-keep',
                        action='store_true',
                        help='Keep intermediate files.')

    parser_settings.add_argument('-bamstats',
                        help='Path to _bamstats.txt file generated by previous detettore run. Reduces running time quite a bit.')

    parser_settings.add_argument('--region',
                        type=str,
                        help='Search TIPs in region chromosome:start-end.')

    parser_settings.add_argument('--include_invariant',
                        action='store_true',
                        help='Include conserved TEs in vcf output.')


    # PARAMETERS
    parser_thresholds.add_argument('-u', dest="uniq",
                        type=int, default=30,
                        help='Difference between XS and AS for a read to be considered uniquely mapped. [30]')

    parser_thresholds.add_argument('-lSR', dest='aln_len_SR',
                        type=int, default=20,
                        help='Minimum alignment length for splitread target hits. [15]')

    parser_thresholds.add_argument('-lDR', dest='aln_len_DR',
                        type=int, default=50,
                        help='Minimum alignment length for discordant read-pair target hits. [50]')

    parser_thresholds.add_argument('-id', dest='perc_id',
                        type=int, default=80,
                        help='Minimum percentage identity of target hits. [80]')

    parser_thresholds.add_argument('-ws', dest='word_size',
                        type=int, default=11,
                        help='Word size (minimum length of best perfect match) for blasting splitreads against TEs. [11]')

    parser_thresholds.add_argument('-c', dest='cpus',
                        type= int, default=1,
                        help='Number of CPU used for the blast search. [1]')

    args=parser.parse_args()

    return args


#%% TEST args

# from Bio import SeqIO

# class args:

#     def __init__(self):

#         self.bamfile = "/home/cristobal/github/detettore/testing/RW-TB008_SRR10828835.bam"
#         self.reference = "/home/cristobal/github/detettore/testing/MTB_ancestor_reference.fasta"
#         self.targets = "/home/cristobal/github/detettore/testing/GCF_000195955.2_ASM19595v2_genomic.fna.is.consensus.fna"
#         self.annot = "/home/cristobal/github/detettore/testing/GCF_000195955.2_ASM19595v2_genomic.mobile_genetic_elements.nameTAG.MTB_anc.gff"
#         self.outfolder = "RW-TB008"

#         self.uniq = 20
#         self.aln_len_DR = 50
#         self.aln_len_SR = 30
#         self.perc_id = 80
#         self.word_size = 11

#         self.modus = ['tips', 'taps']
#         self.cpus = 4
#         self.bamstats = False

#         self.ref_contigs = {seq_record.id:
#                             seq_record.seq for seq_record in SeqIO.parse(self.reference, "fasta")}
#         self.annotation = []
#         self.readinfo = False

# args = args()

# os.chdir("testing")


#%% MAIN

def main():

    #%% Program settings
    args = get_args()

    parameters = strumenti.mise_en_place(args)

    try:
        os.mkdir(args.outfolder)
    except OSError:
        pass
    os.chdir(args.outfolder)


    #%% TIPs
    if "tips" in parameters.modus:

        print('\nSearching TE insertion polymorphisms...')

        tips = strumenti.TIPs()

        # Get discordant read pairs and splitreads
        print('Getting candidate split reads and discordant read pairs from bam file ...')
        DR_anchors, splitreads, split_positions = strumenti.get_split_and_discordant_reads(parameters)
        print('Analysis begins with %i discordant read pairs and %i splitreads.\n' % \
              (len(DR_anchors), len(splitreads)))

        # Discordant read pairs: find anchor clusters with mates mapping to TEs
        tips.discordant_read_pairs(parameters, DR_anchors)
        print(str(len(tips.DR_clusters)) + ' clusters')

        # Same for splitreads
        tips.splitreads(parameters, splitreads, split_positions)
        print(str(len(tips.SR_clusters)) + ' clusters')

        # Combine split and discordant
        tips.combineDR_SR(parameters)

        # VCF output
        tips_vcf = tips.output_vcf(parameters)

        # Clean up

        for g in ['discordant.fasta',
                  'softclipped.fasta'
                  ]:
                os.remove(g)

        print('TIP search finished successfully\n')


    #%% TAPs
    if "taps" in parameters.modus:

        print('Searching TE absence polymorphisms')
        taps = strumenti.TAPs(parameters)
        taps_vcf = taps.output_vcf(parameters)

        print('TAP search finished successfully\n')



    #%% Write VCF and log file

    import time
    import gzip

    combined_vcf = tips_vcf + taps_vcf
    combined_vcf = sorted(combined_vcf, key=lambda x: (x[0], int(x[1])))

    date = time.strftime("%d/%m/%Y")

    metainfo = [

        '##fileFormat=VCFv4.2',
        '##fileDate=%s' % date,
        '##source==detettore v2.0',
        '##reference=%s' % parameters.reference,
        #'##contig=<ID=%s,length=%i,assembly=%s>',

        '##INFO=<ID=MEINFO,Number=4,Type=String,Description="Mobile element info of the form NAME,START,END,POLARITY">',
        '##INFO=<ID=SVTYPE,Number=1,Type=String,Description="Type of structural variant">',
        '##INFO=<ID=SVLEN,Number=.,Type=Integer,Description="Difference in length between REF and ALT alleles">',
        '##INFO=<ID=END,Number=1,Type=Integer,Description="End position of the variant described in this record">',
        '##INFO=<ID=HOMSEQ,Number=.,Type=String,Description="Sequence of base pair identical micro-homology at event breakpoints">',
        '##INFO=<ID=HOMLEN,Number=.,Type=Integer,Description="Length of base pair identical micro-homology at event breakpoints">',
        '##INFO=<ID=DPADJ,Number=.,Type=Integer,Description="Read Depth of adjacency">',
        '##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description="Imprecise structural variation">',
        '##INFO=<ID=CIPOS,Number=2,Type=Integer,Description=“Confidence interval around POS for imprecise variants”>',
        '##INFO=<ID=DR,Number=2,Type=Integer,Description="Discordant reads">',
        '##INFO=<ID=SR,Number=2,Type=Integer,Description="Split reads">',
        '##INFO=<ID=AL,Number=1,Type=Integer,Description="TE alignment length">',

        '##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">',
        '##FORMAT=<ID=GQ,Number=1,Type=Integer,Description="Genotype quality">',
        '##FORMAT=<ID=DP,Number=2,Type=Integer,Description="Number of ALT supporting reads.">',

        '##ALT=<ID=INS:ME,Description=Transposable element insertion polymorphism (TIP)>',
        '##ALT=<ID=DEL:ME,Description=Transposable element absence polymorphism (TAP)>'
        ]

    with gzip.open(args.outfolder + '.detettore.vcf.gz', 'wt') as f:

        f.write('\n'.join(metainfo))

        for line in combined_vcf:

            f.write('\t'.join(map(str, line)) + '\n')



    # Create log file
    logging.basicConfig(
            filename = 'logfile.txt',
            format = '%(levelname)-10s %(asctime)s %(message)s',
            level = logging.INFO)
    log = logging.getLogger('logfile.txt')
    log.info(args)



if __name__ == '__main__':
    main()
